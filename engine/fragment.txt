#version 330 core

uniform vec3 scale;

uniform vec3 colors[5];

uniform float size_of_array;
uniform float terr_max;
uniform float terr_min;

in vec3 pos;
out vec3 color;

/*
vec3 Gradient(float position, vec3 color1,vec3 color2,vec3 color3,vec3 color4,vec3 color5, float s,float min){
	if(position > 4*s+min){
	float mPct = smoothstep(5*s+2*min, 4*s+min, position);
	 return mix(color1,color2,mPct);
	}
	else if(position > 3*s+min){
		float mPct = smoothstep(4*s+2*min, 3*s+min, position);
	 return mix(color2,color3,mPct);
	}
	else if(position > 2*s+min){
		float mPct = smoothstep(3*s+min, 2*s+min, position);
	 return mix(color3,color4,mPct);
	}
	else if(position > 1*s+min){
		float mPct = smoothstep(2*s+min, 1*s+min, position);
	 return mix(color4,color5,mPct);
	}
	else{
	 return color5;
	}
}
*/

vec3 Gradient(float position, vec3 array[5], float min, float max, float yscale, float size){
	
	float interval = yscale*(max-min)/size;
	for(int i = 0; i < int(size); i++)
	{
		if(position > ((size-i)*interval+min))
		{
			float mPct = smoothstep((size-i+1)*interval+min, (size-i)*interval+min, position);
			return mix(array[i],array[i+1],mPct);
		}
	}
	
	
	return array[int(size)];
	
	
}
void main(){

	color = Gradient(pos.y,colors,terr_min, terr_max, scale.y,size_of_array/15);
	
	}