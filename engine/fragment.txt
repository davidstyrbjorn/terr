#version 330 core
#define MAX 100
uniform vec3 scale;

uniform vec3 colors[MAX];

uniform float size_of_array;


in vec3 pos;
out vec3 color;

/*
vec3 Gradient(float position, vec3 color1,vec3 color2,vec3 color3,vec3 color4,vec3 color5, float s,float min){
	if(position > 4*s+min){
	float mPct = smoothstep(5*s+2*min, 4*s+min, position);
	 return mix(color1,color2,mPct);
	}
	else if(position > 3*s+min){
		float mPct = smoothstep(4*s+2*min, 3*s+min, position);
	 return mix(color2,color3,mPct);
	}
	else if(position > 2*s+min){
		float mPct = smoothstep(3*s+min, 2*s+min, position);
	 return mix(color3,color4,mPct);
	}
	else if(position > 1*s+min){
		float mPct = smoothstep(2*s+min, 1*s+min, position);
	 return mix(color4,color5,mPct);
	}
	else{
	 return color5;
	}
}
*/

vec3 Gradient(float position, vec3 array[MAX], float yscale, float size){
	if(int(size) == 1){
	return array[0];
	}
	
	for(int i = 0; i < size-1; i++)
	{
		if(position> yscale*(int(size)-1-i)/int(size))
		{
			float mPct = smoothstep(yscale*(int(size)-i)/int(size),yscale*(int(size)-1-i)/int(size), position);
			return mix(array[i],array[i+1],mPct);	
		}
	}
	
	return array[int(size)-1];
}

void main(){
	color = Gradient(pos.y,colors, scale.y, size_of_array);
}